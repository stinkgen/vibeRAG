Perfect. I’ll dig into the architecture and design docs for vibeRAG and create a clear implementation plan for adding multi-user support with local authentication, an admin UI, per-user Milvus collections, and persistent memory using SQLite.

I’ll make sure the plan stays focused, avoids scope creep, and supports backend-only API access securely.
I’ll get back to you shortly with a structured proposal.

# Multi-User & Authentication Implementation Plan for VibeRAG

We propose a multi-phase plan to evolve VibeRAG into a multi-user, authenticated system. The plan adds account management, role-based access (admin vs. standard users), per-user data isolation, and persistent chat history storage – all while preserving the existing architecture's simplicity and focusing on robustness and extensibility. Each phase below outlines the required changes and design decisions, with minimal impact on the current system’s surface complexity.

## Phase 1: Basic Authentication and Landing Page

- **User Account Model & Storage:** Introduce a **User** model with fields for username, hashed password, role (admin flag), and active status. Use a lightweight SQLite database to store users and credentials. This follows the project’s preference for simple local integrations (adding a DB, as suggested for chat history persistence ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=,adding%20DB%20integration%20to%20backend))). On startup, seed the database with a default **admin** account (username: “admin”, password: “admin”) if no users exist. Ensure passwords are stored securely (e.g. using Bcrypt hashing) for robustness.

- **JWT Token Authentication:** Implement stateless authentication using JSON Web Tokens. Add a new **login API endpoint** (e.g. `POST /api/v1/auth/login`) where users submit username/password. The backend verifies credentials against the SQLite user store, and if valid, returns a signed JWT token (with a secret defined in config). The token will encode at least the user ID and role (admin or not), and have an expiration (for security). The backend will **not rely on browser sessions** – instead, all subsequent requests must include the token (in an `Authorization: Bearer <token>` header). This satisfies the requirement that the backend remain usable via direct HTTP calls with auth headers, without a dedicated frontend session mechanism.

- **Protecting API Endpoints:** Add a middleware or dependency in the FastAPI app to enforce authentication on all API routes (except login and health checks). On each request, the backend will decode and validate the JWT. It will also check the user’s status (lookup in DB) to ensure the account is active and not disabled, adding an extra layer of authorization. If the token is missing or invalid, return HTTP 401 Unauthorized (the Node.js proxy will simply forward this to the client). This approach keeps security in the backend (FastAPI) as recommended ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=,Reloading%3A%20Reconfigure%20%60frontend%2FDockerfile%60%20and%20%60docker)), rather than depending on the Node proxy.

- **Frontend Landing & Login UI:** Create a **Login page** as the entry point to the React app. When the app loads, it should detect if the user is not authenticated and, if so, display a login form (username & password fields). This can be a new component (e.g. `Login.tsx`) and route. Keep the design simple – a logo or title and the form. On form submission, call the `POST /auth/login` API via the proxy (which forwards to backend). If successful, store the returned token (e.g. in `localStorage` or in-memory context on the client) and proceed to load the main app UI. All subsequent API calls from the frontend must include this token. We will update the frontend API utility (e.g. `api.ts`) or Axios global config to automatically attach the `Authorization` header on requests. The existing Node.js proxy should be configured to forward **all headers** (including Authorization) to the backend, to support this token passing (ensuring the proxy’s use of `axios` doesn’t drop auth headers). Once logged in, the user sees the normal VibeRAG interface (Chat, Document Manager, etc.).

- **Configuration:** Add any new settings to the config system (e.g. JWT secret, token expiration) via environment variables, following the existing pattern of using the global `CONFIG` object ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,specific%20JSON%20structures%2C%20which%20are)). This keeps the solution extensible and consistent with current design.

- **Default Admin Credentials Warning:** Prompt the admin (e.g. via a notice on first login or in docs) to change the default password. This can be a simple banner or message on the UI after login if the default credentials are used, emphasizing security.

*(Outcome:* VibeRAG now has a login gate and token-based auth. Only authenticated users can access the API/UI. By using JWT and header auth, the system can be accessed programmatically via HTTP, fulfilling the “no front-end dependency” requirement.*)

## Phase 2: Admin Role and User Management Interface

- **Admin Role & Authorization:** Leverage the admin flag on user accounts to restrict management features. The default admin user (and any user marked as admin in the DB) will have elevated privileges. Authorization checks in the backend will ensure only admin tokens can access certain endpoints (e.g. user management, global collection management).

- **User Management Endpoints:** Implement new **Admin APIs** for managing user accounts:
  - `GET /api/v1/users` – **List Users:** Admin-only. Returns a list of all user accounts with basic info (e.g. user ID, username, role, active status). This allows the admin UI to display existing accounts.
  - `POST /api/v1/users` – **Create User:** Admin-only. Accepts a JSON body with new user's username, initial password, and (optionally) role or profile info. Creates a new user (with password hashed) and initializes their resources (e.g. creates their Milvus collection, see Phase 3). By default, new users are active/enabled.
  - `PUT /api/v1/users/{id}` – **Update User:** Admin-only. Allows toggling a user's `active` status (enable/disable an account login) and updating basic profile info. For example, the admin can disable a user (preventing future logins) or promote a user to admin (if multi-admin support is desired later). This endpoint can also be used to reset a user’s password (admin provides a new password, which gets hashed and saved).
  - `DELETE /api/v1/users/{id}` – **Delete User:** Admin-only. Removes a user account. This will not only remove the user from the SQLite DB but also trigger cleanup of any user-specific data – e.g. drop their Milvus collection and delete their uploaded documents (for privacy and to free space). We must carefully remove or archive all assets owned by that user.
  - `PUT /api/v1/users/{id}/password` – (Optional) **Change Password:** Could be merged into the above update, but might also provide a dedicated route for changing passwords. In any case, all password changes must re-hash the password. Admins can use this to change their own password as well (or we can have a separate self-service endpoint for the logged-in user to change their own password without needing the old one, since they are already authenticated).

- **Admin Web Interface:** Add a new **Admin Console** in the frontend (visible only to admin users). This could be a new page/component (e.g. `AdminPanel.tsx`) accessible via the sidebar or the config menu. Keep it simple and utilitarian:
  - Display the list of users (from `GET /users`), perhaps in a table with columns: Username, Role (Admin/User), Active (Yes/No), and actions.
  - Provide controls for each user: 
    - **Disable/Enable:** a toggle or button to set active status (using the update API).
    - **Reset Password:** maybe a button that opens a prompt to input a new password for that user (calls update API).
    - **Delete:** a button to remove the user (after confirmation).
  - Provide a form to **Create New User:** allowing admin to input a username and password (and possibly a checkbox for admin role). This calls `POST /users`. We will not implement self-signup for users; all accounts are created by the admin to avoid scope creep (no email verification flow, etc.).
  - Provide an interface for admin’s own profile: At minimum, a **Change Password** form for the admin account (so they can change the default admin password or update it regularly). This could be in the AdminPanel or in a user dropdown menu – but to keep surface complexity low, we can include it in the AdminPanel screen (e.g. a section "Change Your Password").

- **Feedback and Validation:** The admin UI should give feedback for actions (e.g. “User created successfully”, “Password updated”, etc.). Use existing UI patterns for notifications if available, or simple alerts. Validate inputs on the frontend (e.g. non-empty password, unique username not already taken – which can also be enforced on backend with a unique index on username).

- **Security Considerations:** Only an authenticated admin should reach the admin UI. We will ensure the frontend does not even show the Admin Console link for non-admin users. Additionally, the backend will double-check admin privileges on every admin API call (even if the UI hides it, we enforce on server). This dual layer prevents privilege escalation. All admin actions are authenticated via JWT as usual.

- **Extensibility:** The user management framework sets the stage for future enhancements (like assigning roles/permissions beyond admin, or integrating OAuth in the future). The current implementation focuses on local accounts only, keeping it straightforward. We avoid adding any third-party auth or complex role hierarchies at this time (minimal initial scope).

*(Outcome:* An admin user can log in and manage accounts through a dedicated interface. They can create new user logins, deactivate or delete users, and update passwords. This provides basic multi-user administration within the app, all behind proper authorization checks.*)

## Phase 3: Per-User Data Isolation in Milvus (Multi-Tenancy)

- **Milvus Collections per User:** Reconfigure the vector database usage to create **separate Milvus collections for each user’s data**, plus a global collection. Currently, VibeRAG uses a single collection for all documents/embeddings (as implied by the single-tenant design). We will extend this by maintaining multiple collections:
  - A **Global Collection** (e.g. named `"global"`): Owned/managed by Admin – this will store documents intended to be shared across all users.
  - A **Private Collection for Admin** (e.g. `"admin"` or `"user_admin"`): Admin’s personal documents that are not shared globally.
  - One **Private Collection per regular user** (e.g. `"user_<username>"` or `"user_<id>"`). Each user’s uploaded documents and vectors go into their own collection.

  Using distinct collections ensures strict data separation: when a user searches or lists documents, they will by default only interact with their own collection (and the global collection where appropriate). We leverage Milvus’s collection isolation to enforce multi-user data security.

- **Lifecycle of Collections:** On application startup, ensure the existence of the key collections:
  - If not already present, create the `global` collection in Milvus (with the same schema as the current default: an embedding vector field and metadata fields, etc.).
  - Also ensure the admin’s personal collection exists (create if missing).
  - When a new user account is created (Phase 2), immediately create a Milvus collection for that user. This can be done within the `POST /users` handler – after adding the user to SQLite, call Milvus (via `pymilvus`) to create a new collection named for that user. Use a consistent naming scheme (for example, prefix with `user_` and the user’s unique ID or username). The schema (dimension, metric type, etc.) will mirror the existing one (which is defined in config and used for the single collection currently). This approach avoids a monolithic collection with user IDs in metadata, and instead uses Milvus’s internal partitioning by collection, which is simpler to reason about.

- **Document Ingestion Changes:** Update the document upload and management logic to be **user-aware**:
  - The `POST /upload` endpoint will determine which collection to insert into based on the authenticated user. If the user is a normal user, their file is indexed in their private collection. If the user is the admin, we need to decide whether the document goes to the global collection or admin’s private collection. We will support both:
    - By default, admin uploads could go into their **personal** collection, unless they explicitly choose to add to global. To allow choice, we can extend the upload API (and UI) to accept a parameter indicating the target collection (e.g. `?global=true` or a field in the form). In the UI, the admin might have a toggle or option "Add to global knowledge base" when uploading a document. If that flag is set, the backend will store the document in the global collection; otherwise in admin’s own.
    - For simplicity, normal users will not see this option – all their uploads are inherently private.
  - Adjust the ingestion pipeline (`ingest.py` and `milvus_ops.py`) to use the correct Milvus collection. We might pass the collection name as an argument to the `upload_document` function or determine it from `current_user` context. The Milvus client calls (insert, etc.) need the collection name. This likely means *not* using a single `CONFIG.milvus.collection` value for all operations, but dynamically substituting with the user's collection. We maintain robustness by reusing the same vector dimensions and indexing settings for all collections.
  - **File Storage:** Currently, uploaded files are saved to the `storage/documents` volume with their filename ([vibeRAG/docs/REFERENCE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/REFERENCE.md#:~:text=,distinct%20filenames%20and%20associated%20metadata%2Ftags)) ([vibeRAG/docs/REFERENCE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/REFERENCE.md#:~:text=,vector_store%2Fmilvus_ops.py)). In a multi-user scenario, filename collisions or unauthorized access could occur. We will partition file storage per user to mirror the collection separation. For example, save files under `storage/documents/<username>/filename`. The `UploadResponse` and subsequent retrievals will incorporate this path. The `GET /get_pdf/{filename}` endpoint must be adjusted to ensure the file is fetched from the correct user’s folder (and that users can’t fetch others’ files). We can include the user context or collection name in that request/endpoint (e.g. `GET /get_pdf/user/{username}/{filename}`), or derive it from the authenticated user on the server side. This change ensures users only ever access their own uploaded file content or global files (if we allow global files to be fetched, e.g. for admin or read-only for others).
  - **Metadata:** Milvus stores document metadata (filename, tags, etc.) as a JSON string in each vector record ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,place%20update%2C%20which%20might)). We should include an identifier of the collection or owner in the metadata if needed (though not strictly necessary since the collection itself segregates data). It may help for admin to know which collection a doc belongs to if managing many, but the UI will handle that by separate queries.

- **Document Listing and Management:** Adjust the `GET /list` and other document management endpoints:
  - For a **normal user** requesting `/list`: return the documents in their personal collection. We will likely query Milvus for that user’s collection only, since that yields all filenames they’ve uploaded ([vibeRAG/docs/REFERENCE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/REFERENCE.md#:~:text=,storage%2Fdocuments)). We also need to consider **global documents** – if we want users to be aware of global knowledge base entries, we can also retrieve documents from the global collection and include them in the list (marked as global). This allows users to see what shared documents exist. To do this, perform two queries: one on the user’s collection, one on `global`, then merge the results. For any doc coming from the global set, mark it (e.g. an `owner: "global"` field in the response). The UI can display global documents (perhaps with a label or separate section) and differentiate them from the user’s own. **Non-admin users** should likely have read-only access to global docs: they can see and use them in queries, but **cannot delete or edit** them. We will enforce that by not providing delete/edit options in the UI for global docs when logged in as non-admin, and also by the backend refusing any deletion of global docs from non-admin tokens.
  - For the **admin user** requesting `/list`: the admin might need to manage both global and personal documents. We can handle this in one of two ways:
    - **Option A:** Return two sets of documents (or one combined list) including both admin’s personal docs and global docs (marked accordingly). The admin UI could then, for example, separate them into “Your Documents” and “Global Documents” lists. This gives the admin a full overview.
    - **Option B:** Provide a query parameter or separate endpoints to list global vs personal explicitly (e.g. `/list?scope=global` to list global docs, `/list?scope=personal` for the admin’s own). This might simplify the UI logic. We could implement both scopes and have the admin UI call each and display accordingly.
    - In either case, ensure the admin can manage global documents (delete or update metadata) via the Document Manager interface, and likewise manage their personal documents. Admin has full permissions on both collections.
  - **Delete Document (`DELETE /delete/{filename}`):** Now must consider collection context. The endpoint URL as-is doesn’t specify which collection, so the backend will infer it: it can check the user’s collection for that filename, and if not found and user is admin, check global. We might also include a request parameter or payload to specify if the target is global (especially for admin deleting global docs). For safety: 
    - If a normal user calls delete, only delete from their own collection (if filename exists there). They have no ability to delete global docs – if the filename is only in global, return an authorization error.
    - If admin calls delete and the filename exists in global, delete from global; if it exists in admin’s own collection, delete that; potentially, if we later allow admin to delete another user’s document (not in scope initially, as admin isn’t necessarily moderating user content), that would be a separate case (out of current scope unless needed for cleanup when removing a user).
  - **Update Metadata (`PUT /documents/{filename}/metadata`):** Similarly, direct the update to the correct collection. Likely, we find which collection has that filename for this user context. This could be unambiguous if we require a parameter or if file names are unique per user and global. The backend should ensure a normal user cannot modify a global doc’s metadata. Admin can modify both.
  - **Tags and Knowledge Filters:** The frontend has a `KnowledgeFilter` component that fetches filters from endpoints like `/tags` or `/collections` ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=triggering%20Ollama%20model%20loading%20%28,fully%20implemented%20based%20on%20API)). We will implement or update these endpoints to be user-aware:
    - `/tags` should probably return tags from the user’s collection (and possibly global collection’s tags if including global). We can merge results similar to listing files.
    - `/collections` – this was mentioned but not fully implemented ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=triggering%20Ollama%20model%20loading%20%28,fully%20implemented%20based%20on%20API)). We can use this endpoint to let the frontend know what collections (knowledge bases) are available to the user. For example, for a normal user, `/collections` might return `["<username>", "global"]` (or more user-friendly names) indicating they have their personal and the global knowledge base. For admin, it might return `["admin (personal)", "global"]` (and conceivably could list other users’ collections if we ever allowed admin to search those, but we will *not* do that to respect privacy). Initially, we might not expose other users’ collections at all via the UI or API.
    - With this, the **KnowledgeFilter UI** could allow users to select whether to search “All” (both personal + global) or only one or the other, if that UI is desired. However, to avoid complicating the UI in the first iteration, we may skip implementing a UI toggle for global vs personal search – instead, we can default to always searching both for normal queries. The internal logic can handle merging results as described. We leave the door open to adding such a filter in the future using the `/collections` info.

- **Retrieval (Semantic Search) Adjustments:** The core retrieval function (Milvus vector search) should be enhanced to search the appropriate collection(s):
  - When a user asks a question in chat, the backend should retrieve relevant chunks from that user’s own collection and also from the global collection (since global content is meant to be available to all). We will implement this by performing two similarity search queries – one on the user’s collection, one on global – each returning top-k results (perhaps we take half of the requested `k` from each, or request `k` from each and then combine). Then we merge the results by highest similarity score and take the overall top-k to feed into the prompt. This ensures the user gets the most relevant info regardless of source. (If the vector distances from different collections aren’t directly comparable, we may normalize or just trust the top results from each – in practice, using the same model and metric, the scores are comparable enough to mix.) This logic will be encapsulated in the retrieval module (e.g. extending `retrieval/search.py`) without changing the interface to the generation module. It’s an internal detail that if `current_user` is not admin, we do two searches. If needed, we could allow a flag to only search personal knowledge (if user turns off global), but default will be combined.
  - For admin, the retrieval can similarly search both admin’s personal collection and global (since admin might want answers from both). However, the admin might often know what’s in global vs personal and could filter via UI if we provide that. Initially, we will also combine both for admin queries.
  - **Note:** Searching two collections will have a performance impact (two queries instead of one). Given Milvus is efficient and the data per user is presumably smaller, this is acceptable for now. We keep the design simple; if needed later, we can optimize (for example, using Milvus partitioning or tags to query multiple collections in one call, if supported).
  
- **Maintain Single Backend Service:** We will *not* spin up separate service instances per user or anything heavy – all the logic above runs within the single FastAPI backend, as is current design ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,loaded%20only%20once%20for%20efficiency)). The FastAPI app can manage multiple Milvus collections via the one Milvus client connection (Milvus allows interacting with multiple collections through the same connection). This approach keeps the surface complexity minimal: just additional branching logic based on `current_user`. The config may still hold default collection settings (we might repurpose the existing `CONFIG.milvus.collection` as the base name or template).

- **Testing & Migration:** We will need to migrate any existing data to this new scheme. For example, if the system was previously running with a single user, those documents likely reside in the original collection. We should decide to which new collection those should belong:
  - Possibly treat them as admin’s personal or as global. If the previous usage was just personal to the only user (who is now admin), we could migrate them to admin’s personal collection. If they were intended as shared knowledge, migrate to global. This is a one-time consideration. In the plan, instruct to manually re-ingest if needed or run a migration script.
  - Once in multi-user mode, ensure that new data goes to the correct place and legacy collection (if any) is deprecated.

*(Outcome:* The vector database now cleanly isolates each user’s knowledge base. Regular users cannot access or interfere with each other’s data. An admin-curated global knowledge base is available for all to draw from. Document management functions respect user boundaries. This fulfills multi-tenancy: each user’s interactions are sandboxed to their data plus whatever admin chooses to share globally.)

## Phase 4: Persistent Chat History per User (SQLite-backed)

- **Rationale:** Currently, chat conversation history is stored in the browser (localStorage) and not persisted on the backend ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,ModelSelector.tsx)) ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=%2A%20Frontend%20Hot,Security%3A%20No%20authentication%2Fauthorization%20implemented)). This is a known limitation and is not multi-user friendly – if a user switches devices or if multiple users are using the system, the history doesn’t travel with the account. We will implement server-side persistent chat history using SQLite, on a per-user and per-session basis, as recommended in the contributing guide ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=,adding%20DB%20integration%20to%20backend)).

- **Database Schema:** Expand the SQLite database (from Phase 1) to include tables for chat sessions and messages:
  - **Sessions Table:** Fields might include `session_id` (primary key, could be a UUID or integer), `user_id` (foreign key to Users table), `created_at`, `title` or name (optional – could default to something like first message or a timestamp), and maybe a status (active/ended).
  - **Messages Table:** Fields include `message_id` (PK), `session_id` (FK to Sessions), `sender` (user or assistant system), `content` (text of the message), and `timestamp`. We might also store message type (if needed to distinguish system prompts or other info, though likely just user vs assistant).
  - Each chat session represents a conversation thread. A user can have multiple saved conversations.

- **Session Management Endpoints:** Provide a set of APIs for the frontend to save and retrieve chat history:
  - `POST /api/v1/sessions` – **Start a New Chat Session:** Creates a new session for the authenticated user and returns a `session_id` (possibly also return an initial blank message list). The frontend would call this when the user clicks “New chat” or clears the conversation. Alternatively, we can combine this with the first message send (if the user sends a message without an active session, the backend can auto-create a session).
  - `GET /api/v1/sessions` – **List Sessions:** Returns a list of chat sessions for the user (id and maybe a short summary or timestamp). This could enable a UI list of past conversations to pick from. (If not implementing UI for multiple sessions immediately, this can be a lower priority, but it’s good for extensibility.)
  - `GET /api/v1/sessions/{session_id}` – **Get Session Messages:** Returns the message history (all messages in order) for the given session, if it belongs to the authenticated user.
  - Optionally, `DELETE /api/v1/sessions/{session_id}` to delete a conversation, and `PUT /api/v1/sessions/{session_id}` to rename it (for future user convenience). These are nice-to-have features if we provide a conversation history UI.

- **WebSocket Chat Integration:** Adapt the chat WebSocket (`/ws/chat`) to utilize the stored history:
  - Currently, when a user opens a WebSocket connection for chat, the frontend sends an initial payload including `chat_history_id` (which was likely intended to identify the conversation) ([vibeRAG/docs/REFERENCE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/REFERENCE.md#:~:text=%2A%20%60WS%20%2Fws%2Fchat%60%3A%20Handles%20real,%7D%60%2C)). We will align this `chat_history_id` with our `session_id`. The logic:
    - If the client provides a `chat_history_id` (session id) that exists in the DB and belongs to them, the backend will load the past messages from that session and use them as context for the conversation. This means the LLM prompt can include the recent Q&A pairs from that session, achieving conversational continuity.
    - If no valid `chat_history_id` is provided (e.g. user starts a brand new chat or the first message in a session), the backend will create a new session record and generate a new `session_id`. We can send this back to the client as part of the WebSocket response (perhaps in the first “chunk” or a special message type like `{type: "session", data: <id>}`) so the frontend knows the ID for this conversation and can reuse it for subsequent messages.
  - **Storing Messages:** As the conversation proceeds:
    - When the user sends a message over WS, the backend receives it. We will intercept this and store it in the database as a new message (with sender=user) under the appropriate session. (If the session was just created, use that ID; if continuing, use the provided session id.)
    - The system then generates a response (streamed out as chunks). Once the answer is fully generated (we get a "end" type or have assembled the final answer text), we store the assistant's response in the DB as well (sender=assistant). We might store the entire response at once (concatenating all chunks), or store incrementally as chunks come (not necessary to store every partial chunk, just the final output for history).
    - By storing both user queries and AI answers, we build a full chat transcript in the database that can be retrieved later.
  - **Using History for Prompting:** Modify the prompt construction in `generation/chat_with_knowledge_ws` (or wherever the conversation prompt is built for LLM) to prepend relevant previous messages from the session. For example, include the last N Q&A turns from that session prior to the new query. This gives the LLM conversational memory. We should be cautious not to include too much to overflow token limits, but a typical strategy is last ~5-10 messages or whatever fits. This was not previously implemented (as noted, history was only on frontend), so this will improve the quality of multi-turn dialogues.
  - The contributing guide explicitly notes adding API calls for history and removing localStorage usage ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=,adding%20DB%20integration%20to%20backend)), so our approach matches that guidance.

- **Frontend Adjustments for Chat History:** Update the React `Chat.tsx` component to use the new session-based APIs:
  - Remove reliance on `localStorage` for storing messages (currently it was used to persist chat between page refreshes in a single-user context ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,ModelSelector.tsx))). Instead, when the Chat component mounts or when a user logs in, fetch the list of sessions (if we implement that) or at least the last active session’s messages.
  - Potentially, automatically start a new session when the user logs in for the first time or clicks “New Chat”. The returned session ID will be stored in the component state.
  - When the user sends a message:
    - If it's the first message of a new session, ensure a session ID exists (create one if not already).
    - Pass the `session_id` as `chat_history_id` in the WebSocket message payload (so the backend knows what session this belongs to).
    - Handle receiving a session ID from the backend if the backend chooses to send one upon creation.
  - Provide UI to view past conversations: This could be as simple as showing a dropdown or list of past sessions (titles or timestamps) and letting the user select one to resume. Given minimal initial scope, we might skip a complex UI and simply auto-continue the last session by default. But we will design the backend to allow for it later.
  - Ensure the "Clear chat" function (if present as a button) triggers starting a new session. For example, on clear, we can call `POST /sessions` to get a new session id, and then reset the chat UI to empty (ready for new messages on a fresh session).
  
- **Multi-User Safety:** Each API call for sessions or messages will be authenticated and will filter by the `current_user`. A user can only create/list/get sessions that belong to them (the user_id from the token is used as filter). Even if someone knew another session_id, the backend will not return it unless the user matches – this prevents any cross-account data leak. SQLite will be operating with multiple users’ data but segregated by foreign keys. We will use appropriate indexing on session and message tables for performance since these could grow with chat usage.

- **Consistency and Cleanup:** Consider what happens on user deletion (Phase 2) – we should also delete that user’s chat history (sessions and messages) from the DB to fully clean up. Implement this in the `DELETE /users` handler, to avoid orphaned data. Similarly, if needed, deleting a session could remove associated messages.

- **Testing the Experience:** With persistent history, test that:
  - If a user refreshes the page or logs out and back in, they can retrieve their previous conversations.
  - The chat interface correctly resumes where it left off (showing old messages) and appends new ones.
  - The conversation context is actually used by the LLM (i.e., the model responds in a contextually appropriate way when asked follow-up questions, proving that including prior messages works).
  - No race conditions: e.g., ensure storing a message to DB doesn’t slow down the streaming of responses noticeably (this should be fine; DB writes are quick, but we could do it asynchronously if needed).
  - The SQLite DB access is thread-safe under FastAPI’s concurrency model (SQLite allows concurrent reads, serialized writes – should be okay with the volume we have). We will use a simple approach (FastAPI dependency for DB session or a global connection with a threading lock as needed) – minimal complexity but correct.

*(Outcome:* Users’ conversations are now saved on the server. They persist across sessions and devices, enabling richer multi-turn interactions and continuity. The system no longer relies on the browser for memory, eliminating a single-user assumption. Each user’s chat history is private to them, ensuring isolation in a multi-user setting ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=)). This addresses the session memory goal and improves the UX.)

## Phase 5: Development Approach and Additional Considerations

- **Modularity and “Agent” Pattern:** We will implement these features in a clean, modular way, mirroring VibeRAG’s existing code organization. For example:
  - Create a dedicated module for authentication (e.g. `modules/auth.py` or an `auth` router in FastAPI) to house login logic and JWT utilities.
  - Create a module for user management (e.g. `modules/users.py`) that contains functions for creating, updating users, etc., and any supporting data structures.
  - The chat history could live in a module like `modules/chat_history.py` or similar, separate from the core generation logic except where they intersect. 
  - We will add the new API routes (login, user CRUD, sessions, etc.) to the FastAPI app (likely in `api/app.py` or via including routers) similar to how other features (slides, research) are added ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=,logic%20in)). This keeps the codebase extensible; future contributors can easily find auth-related code in one place.
  - The frontend will also get new components (Login, AdminPanel, etc.) and slight modifications to existing ones (Chat, DocumentManager). We will avoid overloading any one component with too many new responsibilities – for instance, admin features go in a new component rather than cluttering existing UI.

- **Security Hardening:** Focus on robustness:
  - Use proven libraries for JWT and hashing (e.g. PyJWT and bcrypt) instead of custom token logic, to avoid vulnerabilities.
  - Implement proper error handling for auth flows (e.g. return generic "invalid credentials" messages to avoid user enumeration, rate-limit login attempts if needed in the future).
  - Ensure that all admin-only operations are double-checked on the backend (even if the UI hides them from normal users).
  - We will also consider token security: using sufficiently long random secret for JWT signing (stored in .env configuration), and possibly setting an expiration (e.g. tokens valid for 24 hours) to reduce risk of leaked tokens. Non-expired tokens can be invalidated by admin by disabling an account (the auth check will catch the `active=False` and reject the token usage).
  - The token auth means no server-side session state is needed, which keeps the backend stateless aside from the database – this is scalable and aligns with the requirement of using headers for API usage.

- **Performance and Resource Use:** The enhancements should be lightweight:
  - SQLite operations (for user auth and chat history) are fast for the expected load (and the DB is local to the backend container). Using SQLite avoids introducing a heavier DBMS and fits the minimal complexity goal while still providing persistence.
  - Having multiple Milvus collections could increase memory usage on the Milvus side (each collection has its index). We assume a moderate number of users; if it grows, an alternative could be to use Milvus partitions instead. But separate collections is simpler logically. We will monitor Milvus performance and can tweak if needed.
  - The embedding model remains a singleton for all users ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,insert%20pattern)) – we do not spawn new embedding model instances per user. This ensures we don't balloon memory with duplicate models, and all users share the same embedding service instance (since it's thread-safe to use). This is an efficient reuse of resources.
  
- **Minimal Surface Complexity:** We avoid unnecessary features or premature optimizations:
  - No third-party auth (OAuth/OIDC) in this phase – only straightforward local accounts.
  - No complex role hierarchy beyond admin/user.
  - We won’t implement features like account self-registration, password recovery flows, email notifications, etc., as they are beyond the scope and would add complexity.
  - The UI changes will be as simple as possible to achieve functionality: basic forms and tables without fancy stylings (unless the existing UI framework can be reused).
  - We will not introduce large new dependencies or services. Everything reuses the existing containers (the backend API, the Node proxy, the React app, and Milvus). For example, the SQLite DB can be just a file mounted in the backend container’s volume, avoiding deploying a separate DB container.
  - Testing will be kept pragmatic. Rather than extensive mocking or a large test suite (which could slow down development and isn't indicated as a priority by the current project guidelines), we will focus on manual and integration testing of the features. Each phase’s features can be tested by running the system and verifying the behavior through the API and UI (e.g., using the interactive docs at `/docs` for the new endpoints, or using the UI to create accounts and ensure things work). We’ll ensure core use cases are verified but avoid writing excessive unit tests or mocks (“no unnecessary testing or scope bloat” principle).

- **Agent-Based Extension:** The concept of “agent-based” development in VibeRAG (as noted in the docs for adding new generation agents ([vibeRAG/docs/CONTRIBUTING.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/CONTRIBUTING.md#:~:text=,logic%20in))) suggests implementing new capabilities in self-contained modules with clear API endpoints. We follow the same principle here: treating **authentication**, **user management**, and **chat history** as new feature modules or “agents” of a sort. Each has its own endpoints and logic, which are integrated into the app without monolithic rewrites. This keeps the code focused and easier to maintain or extend. For example, if later we want to integrate an OAuth agent or an external user directory, we can swap out or augment the auth module. Or if we want to implement more sophisticated memory (like vector-based conversational memory), it can extend the chat history module.

- **Documentation and Configuration:** Update the project README/docs to reflect these changes:
  - Document how to log in and the default admin credentials.
  - Document the new admin functionalities and how to manage users.
  - Note the new .env settings (like `JWT_SECRET`, etc.) and any new dependency (perhaps Python lib for JWT).
  - Update any deployment instructions since we added a SQLite file (ensure the Docker Compose volume is set so the database file persists if needed).
  - Possibly update the OpenAPI documentation via FastAPI for the new endpoints (they will appear in `/docs` automatically if we add them to the app router).

By executing these phases, we incrementally add multi-user support in a robust manner. Each phase builds on the previous: first securing the system, then enabling multi-user management, then isolating data in the vector DB, and finally enhancing user experience with persistent conversations. Throughout, we preserve VibeRAG’s core design of a single-service backend ([vibeRAG/docs/ARCHITECTURE.md at main · stinkgen/vibeRAG · GitHub](https://github.com/stinkgen/vibeRAG/blob/main/docs/ARCHITECTURE.md#:~:text=,loaded%20only%20once%20for%20efficiency)) and minimal dependencies, ensuring the system remains as simple as possible for both developers and users while significantly extending its functionality.